# Chapter 6: Code Execution

Welcome back! In our previous chapters, we've laid the groundwork for our AI data assistant. We set up the [Streamlit Application Structure](01_streamlit_application_structure_.md) (Chapter 1), handled [Data Loading and Context](02_data_loading_and_context_.md) (Chapter 2), built the [Chat Interface and Flow](03_chat_interface_and_flow_.md) (Chapter 3), mastered [Streamlit Session State](04_streamlit_session_state_.md) (Chapter 4) to remember things, and learned how to interact with the [Ollama Model Interaction](05_ollama_model_interaction_.md) (Chapter 5) to get the AI's response.

Now, here's a crucial step: The AI's response often includes Python code designed to analyze your data or create charts. But this code is just text within the AI's message. How does that text code actually turn into the graph or the calculation you see below the AI's message?

This chapter is all about the **Code Execution** abstraction – the part of the application responsible for finding the Python code in the AI's response and running it safely to produce the final output.

## What Problem Does Code Execution Solve?

Imagine the AI is your smart assistant. You ask it, "Show me a chart of sales over time." The assistant (the AI) writes down the exact steps in Python code to create that chart using the data you provided. But simply writing down the steps isn't enough; you need to actually *perform* those steps to see the chart!

The Code Execution part of our app does just that. It takes the AI's written instructions (the code block), understands where the code is, and then runs it within the app. This allows the AI to not just *talk* about data analysis, but to actually *do* it and show you the results directly in the interface.

The main use case is clear: **execute the Python code generated by the AI to display outputs like charts, tables, or messages.**

## Key Concepts

To make this happen, we need a few key ideas:

*   **Code Block Extraction:** Finding the specific section in the AI's response that contains the Python code, usually marked by special formatting (like triple backticks ` ```python `).
*   **Dynamic Execution:** Running a piece of code that is stored as a string, rather than code that was written directly into your script file beforehand.
*   **Execution Environment:** Making sure the code has access to the necessary data (your DataFrame, `df`) and tools (`streamlit`, `st`) while it's running.
*   **Safety:** While our app runs code generated by a *local* AI model within a restricted environment (Streamlit app), in more complex systems, running arbitrary AI-generated code requires significant safety measures to prevent malicious code from harming the system. For this project, we assume a relatively trusted environment, but the concept of controlling *what* the code can access is relevant.
*   **Error Handling:** What happens if the AI generates incorrect or buggy code? The system needs to catch errors and inform the user.

Our app handles these concepts within a single function called `execute`, located in `utils/functions.py`.

## How it Works: The `execute` Function

Let's look at the simplified code for the `execute` function. It takes the AI's full response text as input.

```python
# --- File: DATARS-AI-Chatbot/utils/functions.py ---
# ... (other imports like re for regular expressions, ast) ...
# ... (other functions like get_ollama_stream, get_context) ...
import streamlit as st # Need st to pass to the executed code

# Use Streamlit caching, explained in Chapter 2 & 4
@st.cache_data
def execute(response: str) -> None:
    """
    Extracts and executes Python code embedded within a response string.
    """
    # Step 1: Find the code block
    # Explained below...
    match = re.search(r'```python\s*\n(.*?)```', response, re.DOTALL)

    if match:
        code = match.group(1) # Extract the code inside the block

        # Step 2: Execute the code
        try:
            # Explained below...
            exec(code, {"df": st.session_state.df, 'st':st})
        except Exception as e:
            # Step 3: Handle errors
            # Explained below...
            st.error(f"An error occurred: {e}")

# ... (other functions) ...
```
*Simplified Code from `DATARS-AI-Chatbot/utils/functions.py`*

This function performs three main steps:

1.  **Find the Code Block:** It searches the AI's text response for the Python code block.
2.  **Execute the Code:** If a code block is found, it attempts to run that code.
3.  **Handle Errors:** If running the code causes an error, it catches the error and displays a message to the user.

Let's look at each step in more detail.

### Step 1: Finding the Code Block (`re.search`)

Large Language Models (LLMs) often format code using Markdown syntax, typically enclosing code in triple backticks, sometimes followed by the language name (like ` ```python `).

Example AI response:

```
Okay, I can calculate the average age.

```python
average_age = df['Age'].mean()
st.write(f"The average age is: {average_age:.2f}")
```

Let me know if you need anything else!
```

We need to find the text that is exactly between ` ```python ` and the closing ` ``` `. This is a perfect job for **regular expressions**.

The line `match = re.search(r'```python\s*\n(.*?)```', response, re.DOTALL)` does this:

*   `re.search(...)`: This function from Python's `re` (regular expression) module searches for a pattern within a string.
*   `r'```python\s*\n(.*?)```'`: This is the pattern we're looking for.
    *   ` ```python `: Matches the literal start of the code block.
    *   `\s*`: Matches zero or more whitespace characters (like spaces or tabs) after `python`.
    *   `\n`: Matches the newline character, assuming the code starts on the next line.
    *   `(.*?)`: This is the most important part.
        *   `.`: Matches any character (except newline by default, but `re.DOTALL` changes this).
        *   `*`: Matches the previous character (`.`) zero or more times.
        *   `?`: Makes the `*` "non-greedy". This means it will match the *shortest* possible string that satisfies the pattern. Without `?`, it would match everything from the *first* ` ```python ` to the *last* ` ``` ` in the entire response, which isn't what we want if there were multiple code blocks.
        *   `()`: The parentheses "capture" the text matched by `.*?`. This captured text is the actual Python code we want.
    *   ` ``` `: Matches the literal end of the code block.
*   `response`: The string we are searching within (the AI's full response).
*   `re.DOTALL`: A flag that makes the `.` character also match newline characters, so the code block can span multiple lines.

If the pattern is found, `re.search` returns a "match object". If not, it returns `None`.

The `if match:` check determines if a code block was found. If it was, `match.group(1)` gives us the text captured by the parentheses `(.*?)`, which is the pure Python code string.

### Step 2: Executing the Code (`exec()`)

Once we have the Python code as a string, we need to run it. Python provides a built-in function specifically for this: `exec()`.

The line `exec(code, {"df": st.session_state.df, 'st':st})` does the actual running:

*   `exec(code, environment)`: The `exec()` function takes a string (`code`) containing Python code and runs it.
*   `{"df": st.session_state.df, 'st':st}`: This is the crucial second argument. It's a dictionary that defines the "global" namespace (or environment) in which the `code` string will be executed.
    *   `"df": st.session_state.df`: This maps the name `df` *within the executed code* to the actual DataFrame object stored in [Streamlit Session State](04_streamlit_session_state_.md) (`st.session_state.df`). This is why the AI can generate code like `df['Age'].mean()` – the `df` variable is available to it!
    *   `'st':st`: This maps the name `st` *within the executed code* to the Streamlit module itself. This allows the AI's generated code to use Streamlit functions like `st.write()` or `plotly.express` plots (which integrate with `st.plotly_chart()`).

When `exec()` runs, it executes the code string as if it were a small, isolated script. Because we provide `df` and `st` in the environment dictionary, any code in the `code` string that refers to `df` or `st` will be able to access the actual DataFrame and Streamlit functions.

This is how the AI's generated plotting code, like `fig = px.histogram(df, x='Age'); st.plotly_chart(fig)`, works. The `df` variable is the user's data, and `st.plotly_chart` is the function to display the plot in Streamlit.

### Step 3: Handling Errors (`try...except`)

What if the code generated by the AI has a mistake? Maybe it tries to use a column name that doesn't exist, or it uses a Pandas function incorrectly. If we ran `exec()` without protection, the app would crash.

The `try...except` block prevents crashes and provides helpful feedback:

```python
        try:
            # Attempt to execute the code
            exec(code, {"df": st.session_state.df, 'st':st})
        except Exception as e:
            # If *any* kind of error happens during execution...
            st.error(f"An error occurred: {e}") # Display the error using Streamlit
```

*   `try:`: We put the code that might cause an error inside the `try` block (`exec(...)`).
*   `except Exception as e:`: If an error occurs within the `try` block, Python jumps to the `except` block. `Exception` is a broad type that catches most common errors. `as e` assigns the error object to the variable `e`, so we can access information about the error (like the error message).
*   `st.error(f"An error occurred: {e}")`: Instead of crashing, we use `st.error()` to display a visible error message in the Streamlit app, showing the user that the code failed and providing the specific error details from the variable `e`.

This makes the app more robust. The user sees that the AI generated bad code, but the app keeps running, allowing them to ask another question.

### The `@st.cache_data` Decorator

The `@st.cache_data` decorator above the `execute` function (explained in [Chapter 2](02_data_loading_and_context_.md) and [Chapter 4](04_streamlit_session_state_.md)) is used here for optimization. Streamlit tries to be smart and re-run as little code as possible. By default, `exec()` is tricky for caching because Streamlit doesn't know what the string `code` will do or what global variables it relies on beyond the ones explicitly passed.

Using `@st.cache_data` on `execute` tells Streamlit to cache the *result* of calling `execute` based on its *input* (`response`). If the AI generates the *exact same* response text again (including the code block), Streamlit might use the cached result instead of re-running `exec`. While the benefit might be minimal if the AI's responses always vary slightly, it's a good practice. Crucially, for the cache to work reliably here, Streamlit needs to correctly track the dependencies (`st.session_state.df`, `st`) used *inside* the function. Streamlit's caching mechanism is designed to handle common dependencies like session state variables and Streamlit objects when used carefully within cached functions.

## How it Fits into the Chat Flow

Remember the `enter` function from [Chapter 3: Chat Interface and Flow](03_chat_interface_and_flow_.md)? That's where `execute` is called.

```mermaid
sequenceDiagram
    participant User
    participant Browser
    participant Streamlit
    participant MainPagePy [pages/Main.py]
    participant Functions [utils/functions.py]
    participant SessionState [Session State]

    User->>Browser: Submits question
    Browser->>Streamlit: Triggers rerun
    Streamlit->>MainPagePy: Executes pages/Main.py (Rerun 1)

    Note over MainPagePy: Detects user input; calls enter()

    MainPagePy->>Browser: Displays User message bubble
    MainPagePy->>MainPagePy: Calls get_ollama_stream(...)
    Note over MainPagePy,Functions: Streaming AI response (from Ch 5)
    MainPagePy->>Browser: Streams AI response into bubble

    Note over MainPagePy: Streaming finishes; st.write_stream returns full response

    MainPagePy->>SessionState: Stores full AI response
    MainPagePy->>Functions: **Calls execute(full_ai_response)**

    Functions->>Functions: Uses re.search() to find code
    alt Code block found
        Functions->>SessionState: Reads st.session_state.df
        Functions->>Functions: Gets access to st module
        Functions->>Functions: **Calls exec(extracted_code, {"df": ..., "st": ...})**
        Note over Functions: The code runs (e.g., calculates, plots using st.)
        Functions->>Browser: (If code used st.write or st.plotly_chart) Sends UI updates
        alt Error during execution
            Functions->>Browser: Sends st.error(...) message
        end
    else No code block found
        Note over Functions: execute finishes without running code
    end

    Functions-->>MainPagePy: Returns (None)

    MainPagePy->>SessionState: Clears user input
    MainPagePy->>Streamlit: Calls st.rerun() (Rerun 2)
    Streamlit->>MainPagePy: Executes pages/Main.py (Rerun 2)
    Note over MainPagePy: Renders full history, displays execution results/errors, clears input, shuffles buttons
    Streamlit->>Browser: Sends updated UI
    Browser->>User: Sees complete turn
```

As you can see, the `execute` function is called right after the AI's complete response has been received and added to the chat history. It runs the extracted code, and any output generated by that code (like plots or `st.write` messages) appears immediately below the AI's chat bubble in the dedicated container (`con = st.container(border=True); with con: execute(response)`).

## Summary

In this chapter, we explored the Code Execution concept:

*   It solves the problem of running the Python code that the AI generates as part of its response.
*   The `execute` function in `utils/functions.py` is responsible for this.
*   It uses Python's `re` module with a regular expression (`re.search`) to find and extract the Python code block from the AI's response string.
*   It uses Python's built-in `exec()` function to run the extracted code string.
*   Crucially, `exec()` is provided with an execution environment that includes the user's data (`df`) and access to Streamlit functions (`st`), allowing the AI's code to interact with the app and the data.
*   A `try...except` block catches any errors that occur during code execution and displays them to the user using `st.error()`, preventing app crashes.
*   The `execute` function is called as part of the main chat flow after the AI's response is received, ensuring that charts and results appear right after the AI's explanation.

With the ability to load data, talk to the AI, and execute its code, our app is almost complete! The final piece is understanding how those helpful suggested questions are generated. Let's move on to the next chapter to explore [Question Generation](07_question_generation_.md).

[Chapter 7: Question Generation](07_question_generation_.md)

---